/*! sassyjson - v0.0.2 - 2014-01-15 */
// Logs an error at `$position` with `$string` message
// @param $string: error message
// @param $position: pointer position
@function _throw($string, $position) {
  @warn "ERROR::#{$position}::#{$string}";
  @return $position, false;
}

// Move pointer to `$token`
@function _consume($source, $position, $token) {
  $length: str-length($source);
  //$position: _trim($source, $position);

  @if $position > $length {
    @return _throw("Expected `" + $token + "` but reached end of stream.", $position);
  }

  $char: str-slice($source, $position, $position);
  $position: $position + 1;

  @if $char == $token {
    @return $position;
  }

  @else {
    @return _throw("Expected `" + $token + "` found `" + $char + "`.", $position);
  }
}

// Trim all whitespaces until character found
@function _trim($source, $position) {
  $length: str-length($source);
  @while $position <= $length {
    $char: str-slice($source, $position, $position);

    @if $char == ' ' {
      $position: $position + 1;
    }
    @else {
      @return $position;
    }
  }

  @return $position;
}

// JSON.parse a string
@function _json-decode--string($source, $position) {
  $length: str-length($source);
  $string-start: $position;

  @while $position <= $length {
    $char: str-slice($source, $position, $position);
    $position: $position + 1;

    @if $char == '"' {
      @return ($position, str-slice($source, $string-start, $position - 2));
    }
  }

  @return _throw("Unterminated string.", $position);
}

// JSON.parse a true bool
@function _json-decode--true($source, $position) {
  $length: str-length($source);
  @if $length - $position < 2
  or str-slice($source, $position, $position) != 'r'
  or str-slice($source, $position + 1, $position + 1) != 'u'
  or str-slice($source, $position + 2, $position + 2) != 'e' {
    @return _throw("Unexpected token: `t`.", $position);
  }
  @return ($position + 3, true);
}

// JSON.parse a false bool
@function _json-decode--false($source, $position) {
  $length: str-length($source);
  @if $length - $position < 3
  or str-slice($source, $position, $position) != 'a'
  or str-slice($source, $position + 1, $position + 1) != 'l'
  or str-slice($source, $position + 2, $position + 2) != 's'
  or str-slice($source, $position + 3, $position + 3) != 'e' {
    @return _throw("Unexpected token: `f`.", $position);
  }
  @return ($position + 4, false);
}

// JSON.parse a null value
@function _json-decode--null($source, $position) {
  $length: str-length($source);
  @if $length - $position < 2
  or str-slice($source, $position, $position) != 'u'
  or str-slice($source, $position + 1, $position + 1) != 'l'
  or str-slice($source, $position + 2, $position + 2) != 'l' {
    @return _throw("Unexpected token: `n`.", $position);
  }
  @return ($position + 3, null);
}

// JSON.parse a number
@function _json-decode--number($source, $position) {
  $length: str-length($source);
  $position: $position - 1;
  $strings: '0' '1' '2' '3' '4' '5' '6' '7' '8' '9';
  $numbers:  0   1   2   3   4   5   6   7   8   9;

  $result: 0;
  $divider: 0;
  $minus: false;

  @while $position <= $length {
    $char: str-slice($source, $position, $position);
    $index: index($strings, $char);
    $position: $position + 1;

    @if $char == '-' { $minus: true }
    @else if $char == '.' { $divider: 1 }
    @else {
      $number: nth($numbers, $index);

      @if $divider == 0 {
        $result: $result * 10;
      }
      @else {
        $divider: $divider * 10;
        $number: $number / $divider;
      }

      $result: $result + $number;

      @if $position <= $length
      and not index($strings, str-slice($source, $position, $position))
      and str-slice($source, $position, $position) != '.' {
        @return ($position, if($minus, $result * -1, $result));
      }
    }

  }

  @return ($position, if($minus, $result * -1, $result));
}

// JSON.parse value
@function _json-decode--value($source, $position) {
  $length: str-length($source);
  //$position: _trim($source, $position);

  @while $position <= $length {
    $char: str-slice($source, $position, $position);
    $position: $position + 1;

    @if $char == '{' {
      @return _json-decode--map($source, $position);
    }
    @else if $char == '[' {
      @return _json-decode--list($source, $position);
    }
    @else if $char == 't' {
      @return _json-decode--true($source, $position);
    }
    @else if $char == 'f' {
      @return _json-decode--false($source, $position);
    }
    @else if $char == '"' {
      @return _json-decode--string($source, $position);
    }
    @else if $char == 'n' {
      @return _json-decode--null($source, $position);
    }
    @else if index('1' '2' '3' '4' '5' '6' '7' '8' '9' '0' '-' '.', $char) {
      @return _json-decode--number($source, $position);
    }
    @else if $char == ' ' {
      // do nothing
    }
    @else {
      @return _throw("Unexpected token `" + $char + "`.", $position);
    }
  }

  @return _throw("Empty JSON string.", $position);
}

// JSON.parse a an array to a list
@function _json-decode--list($source, $position) {
  $length: str-length($source);
  //$position: _trim($source, $position);
  $list: ();
  $needs-comma: false;

  @if $position <= $length and str-slice($source, $position, $position) == "]" {
    @return ($position + 1, $list);
  }

  @while $position <= $length {
    $char: str-slice($source, $position, $position);

    @if $char == "]" {
      @if not $needs-comma {
        @return _throw("Unexpected comma in array literal.", $position);
      }

      // Do it the Sass way and destruct a single item
      // array to an element.
      // eg. ((true) (false) (false true) true) becomse (true false (false true) true)
      @if length($list) == 1{
        @return ($position + 1, nth($list, 1));
      }
      @else{
        @return ($position + 1, $list);
      }
    }

    @else if $char == "," {
      @if not $needs-comma {
        @return _throw("Unexpected comma in array literal.", $position);
      }
      $needs-comma: false;
      $position: $position + 1;
    }

    @else {
      @if $needs-comma {
        @return _throw("Missing comma in array literal.", $position);
      }
      $read: _json-decode--value($source, $position);
      $position: nth($read, 1);
      $list: append($list, nth($read, 2));
      $needs-comma: true;
    }

    //$position: _trim($source, $position);
  }

  @return _throw("Unterminated array literal.", $position);
}

// JSON.parse an object to a map
@function _json-decode--map($source, $position) {
  $length: str-length($source);
  //$position: _trim($source, $position); // Remove spaces before key
  $map: ();
  $needs-comma: false;

  // Deal with empty map
  @if $position <= $length and str-slice($source, $position, $position) == "}" {
    @return ($position + 1, $map);
  }

  @while $position <= $length {
    $char: str-slice($source, $position, $position);
    $position: $position + 1;

    @if $char == "}" {
      @if not $needs-comma {
        @return _throw("Unexpected comma in object literal.", $position);
      }
      @return ($position, $map);
    }

    @else if $char == "," {
      @if not $needs-comma {
        @return _throw("Unexpected comma in object literal.", $position);
      }
      $needs-comma: false;
    }

    @else if $char == '"' {
      @if $needs-comma {
        @return _throw("Missing comma in object literal.", $position);
      }

      // Read key
      $read-key:  _json-decode--string($source, $position);
      $position: nth($read-key, 1);
      $key:      nth($read-key, 2);

      // Remove colon
      $token: ":";
      $position: _consume($source, $position, $token);
      @if length($position) > 1 { // If consume has failed
        @return _throw("Consuming token `" + $token + "` failed.", 0); 
      } 

      // Read value
      $read-value: _json-decode--value($source, $position);
      $position: nth($read-value, 1);
      $value:    nth($read-value, 2);

      // Add pair to map
      $map: map-merge($map, ($key: $value));
      $needs-comma: true;
    }

    @else {
      @return _throw("Unexpected token in object literal.", $position);
    }

    //$position: _trim($source, $position); // Remove spaces for next round
  }

  @return _throw("Unterminated object literal.", $position);
}

// JSON.parse a string
// @param $json: json string to parse
// @return literal
@function json-decode($json) {
  @if $json == null {
    @return _throw("Input string may not be null", $position);
  }

  $position: _trim($json, 1);
  $value: null;

  @while $position <= str-length($json) and $value != false {
    $read: _json-decode--value($json, $position);


    $position: nth($read, 1);
    $value: nth($read, 2);
  }

  @return $value;
}

// Proof quote a value
// @param $value: value to be quoted
// @return [string]
@function _proof-quote($value) {
  @return '"' + $value + '"';
}

// JSON.stringify a bool
// @param $bool: bool to be stringified
// @return [bool]
@function _json-encode--bool($boolean) {
  @return $boolean;
}

// JSON.stringify a color
// @param $color: color to be stringified
// @return [color]
@function _json-encode--color($color) {
  @return _proof-quote($color);
}

// JSON.stringify a list
// @param $list: list to be stringified
// @return [list]
@function _json-encode--list($list) {
  $str: "";
  @each $item in $list {
    $str: $str + ', ' + json-encode($item);
  }
  @return '[' + str-slice($str, 3) + ']';
}

// JSON.stringify a map
// @param $map: map to be stringified
// @return [map]
@function _json-encode--map($map) {
  $str: "";
  @each $key, $value in $map {
    $str: $str + ', ' + _proof-quote($key) + ': ' + json-encode($value);
  }
  @return '{' + str-slice($str, 3) + '}';
}

// JSON.stringify a number
// @param $number: number to be stringified
// @return [number]
@function _json-encode--number($number) {
  @return $number;
}

// JSON.stringify a string
// @param $string: string to be stringified
// @return [string]
@function _json-encode--string($string) {
  @return _proof-quote($string);
}

// JSON.stringify a null
// @param $null: a sass null to be stringified
// @return [string] with content null
@function _json-encode--null($null) {
  @return "null";
}

// JSON.stringify a value and pass it as a font-family of head element
// @param $value: value to be stringified
@mixin json-encode($value) {
  head {
    font-family: json-encode($value);
  }
}

// JSON.stringify a value
// @param $value: value to be stringified
// @return [string |  false]
@function json-encode($value) {
  $types: list, map, number, string, bool, color;
  $value-type: type-of($value);
  @if $value-type != null or index($types, $value-type) {
    @return call('_json-encode--#{$value-type}', $value);
  }
  @warn "Unknown type for #{$value}.";
  @return false;
}
